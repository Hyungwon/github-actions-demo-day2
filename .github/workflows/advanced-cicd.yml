# Day2 실습용 고급 CI/CD 파이프라인
name: Advanced CI/CD Pipeline

on:
  push:
    branches: [ day2-advanced, develop, feature/* ]
  pull_request:
    branches: [ day2-advanced, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: '배포 환경을 선택하세요'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: docker.io
  IMAGE_NAME: github-actions-demo-day2

jobs:
  # 코드 품질 검사
  quality-check:
    name: 코드 품질 검사
    runs-on: ubuntu-latest
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: Node.js 설정
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 의존성 설치
      run: npm ci
      
    - name: 린팅 검사
      run: npm run lint
      
    - name: 코드 포맷팅 검사
      run: npm run format -- --check
      
    - name: 보안 감사
      run: npm audit --audit-level moderate
      
    - name: 의존성 취약점 검사
      run: |
        npm audit --audit-level high
        if [ $? -ne 0 ]; then
          echo "High severity vulnerabilities found"
          exit 1
        fi

  # 멀티 환경 테스트
  test:
    name: 멀티 환경 테스트
    runs-on: ubuntu-latest
    timeout-minutes: 5
    strategy:
      matrix:
        node-version: [16, 18, 20]
        environment: [staging, production]
    services:
      postgres:
        image: postgres:13-alpine
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_DB: myapp_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:6-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: Node.js ${{ matrix.node-version }} 설정
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: 의존성 설치
      run: npm ci
      
    - name: PostgreSQL 클라이언트 설치
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client
      
    - name: 환경 변수 설정
      run: |
        echo "NODE_ENV=${{ matrix.environment }}" >> $GITHUB_ENV
        echo "DB_HOST=localhost" >> $GITHUB_ENV
        echo "DB_PORT=5432" >> $GITHUB_ENV
        echo "DB_NAME=myapp_test" >> $GITHUB_ENV
        echo "DB_USER=postgres" >> $GITHUB_ENV
        echo "DB_PASSWORD=password" >> $GITHUB_ENV
        echo "REDIS_HOST=localhost" >> $GITHUB_ENV
        echo "REDIS_PORT=6379" >> $GITHUB_ENV
        echo "REDIS_PASSWORD=" >> $GITHUB_ENV
        echo "PORT=3000" >> $GITHUB_ENV
      
    - name: 데이터베이스 초기화
      run: |
        echo "🗄️ 데이터베이스 초기화를 시작합니다..."
        echo "환경 변수 확인:"
        echo "DB_HOST: $DB_HOST"
        echo "DB_PORT: $DB_PORT"
        echo "DB_NAME: $DB_NAME"
        echo "DB_USER: $DB_USER"
        echo "NODE_ENV: $NODE_ENV"
        
        # 데이터베이스 연결 대기
        echo "⏳ 데이터베이스 연결을 기다리는 중..."
        timeout 60 bash -c 'until pg_isready -h localhost -p 5432 -U postgres; do sleep 2; done'
        
        # 데이터베이스 사용자 역할 생성
        echo "👤 데이터베이스 사용자 역할 생성..."
        PGPASSWORD=password psql -h localhost -p 5432 -U postgres -d myapp_test -c "
          DO \$\$
          BEGIN
              IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'myapp_user') THEN
                  CREATE ROLE myapp_user WITH LOGIN PASSWORD 'password';
              END IF;
          END
          \$\$;
          GRANT CONNECT ON DATABASE myapp_test TO myapp_user;
          GRANT USAGE ON SCHEMA public TO myapp_user;
          GRANT CREATE ON SCHEMA public TO myapp_user;
        " || echo "⚠️ 사용자 역할 생성 중 오류 발생 (이미 존재할 수 있음)"
        
        # 마이그레이션 실행
        echo "🔄 데이터베이스 마이그레이션 실행..."
        npm run db:migrate
        
        # 시드 데이터 실행
        echo "🌱 시드 데이터 생성..."
        npm run db:seed
        
        echo "✅ 데이터베이스 초기화 완료!"
      
    - name: 애플리케이션 시작
      run: |
        echo "🚀 애플리케이션을 백그라운드에서 시작합니다..."
        
        # 환경 변수 확인
        echo "환경 변수 확인:"
        echo "PORT: $PORT"
        echo "DB_HOST: $DB_HOST"
        echo "DB_PORT: $DB_PORT"
        echo "DB_NAME: $DB_NAME"
        echo "DB_USER: $DB_USER"
        echo "REDIS_HOST: $REDIS_HOST"
        echo "REDIS_PORT: $REDIS_PORT"
        echo "REDIS_PASSWORD: '$REDIS_PASSWORD'"
        
        # 로그 디렉토리 생성
        mkdir -p logs
        
        # 애플리케이션 시작
        npm start > app.log 2>&1 &
        APP_PID=$!
        echo "애플리케이션 PID: $APP_PID"
        
        # 애플리케이션 시작 대기
        echo "⏳ 애플리케이션 시작을 기다리는 중..."
        for i in {1..15}; do
          if curl -f http://localhost:3000/health >/dev/null 2>&1; then
            echo "✅ 애플리케이션이 성공적으로 시작되었습니다!"
            break
          fi
          echo "시도 $i/15: 애플리케이션 시작 대기 중..."
          sleep 2
        done
        
        # 최종 확인
        if ! curl -f http://localhost:3000/health >/dev/null 2>&1; then
          echo "❌ 애플리케이션 시작 실패"
          echo "애플리케이션 로그:"
          cat app.log || echo "로그 파일을 읽을 수 없습니다"
          echo "실행 중인 Node.js 프로세스:"
          ps aux | grep node || echo "Node.js 프로세스를 찾을 수 없습니다"
          kill $APP_PID 2>/dev/null || true
          exit 1
        fi
      
    - name: 테스트 데이터 정리
      run: |
        echo "🧹 테스트 데이터 정리 중..."
        PGPASSWORD=password psql -h localhost -p 5432 -U postgres -d myapp_test -c "
          DELETE FROM system_metrics WHERE metric_name LIKE 'test_%' OR metric_name LIKE '%test%';
          DELETE FROM app_logs WHERE message LIKE '%test%' OR message LIKE '%Test%';
          DELETE FROM users WHERE username LIKE '%test%' AND username NOT IN ('admin', 'testuser', 'demo');
        " || echo "테스트 데이터 정리 완료 (일부 오류 무시)"
        echo "✅ 테스트 데이터 정리 완료"
      
    - name: 서비스 상태 확인
      run: |
        echo "🔍 서비스 상태 확인 중..."
        
        # PostgreSQL 상태 확인
        echo "📊 PostgreSQL 상태:"
        PGPASSWORD=password psql -h localhost -p 5432 -U postgres -d myapp_test -c "SELECT version();" || echo "PostgreSQL 연결 실패"
        
        # Redis 상태 확인
        echo "🔴 Redis 상태:"
        redis-cli -h localhost -p 6379 ping || echo "Redis 연결 실패"
        
        # 애플리케이션 헬스체크
        echo "🏥 애플리케이션 헬스체크:"
        timeout 30 bash -c 'until curl -f http://localhost:3000/health; do sleep 2; done' || echo "애플리케이션 헬스체크 실패"
      
    - name: 단위 테스트 실행
      run: |
        echo "🧪 단위 테스트 실행 중..."
        
        # Jest 실행 (간단한 방식)
        if timeout 60 npm run test:unit; then
          echo "✅ 단위 테스트 성공"
        else
          echo "❌ 단위 테스트 실패"
          exit 1
        fi
      
    - name: 통합 테스트 실행
      run: |
        echo "🔗 통합 테스트 실행 중..."
        
        # Jest 실행 (간단한 방식)
        if timeout 60 npm run test:integration; then
          echo "✅ 통합 테스트 성공"
        else
          echo "❌ 통합 테스트 실패"
          exit 1
        fi
      
    - name: 애플리케이션 정리
      if: always()
      run: |
        echo "🧹 애플리케이션 정리 중..."
        pkill -f "node" || echo "Node.js 프로세스가 이미 종료되었습니다"
        echo "✅ 정리 완료"
      

  # Docker 이미지 빌드 및 푸시
  build-and-push:
    name: Docker 이미지 빌드 및 푸시
    runs-on: ubuntu-latest
    needs: [quality-check, test]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: Docker Hub 로그인
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Docker 이미지 빌드 및 푸시
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:v2.0.0
        labels: |
          org.opencontainers.image.title=GitHub Actions Demo Day2
          org.opencontainers.image.description=Advanced CI/CD Pipeline Demo
          org.opencontainers.image.version=v2.0.0
          org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha

  # 보안 스캔
  security-scan:
    name: 보안 스캔
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: Trivy 보안 스캔
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Trivy 스캔 결과 업로드
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

  # AWS VM 배포
  deploy-aws:
    name: AWS VM 배포
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    environment: aws-staging
    steps:
    - name: AWS VM 배포
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.AWS_VM_HOST }}
        username: ${{ secrets.AWS_VM_USERNAME }}
        key: ${{ secrets.AWS_VM_SSH_KEY }}
        script: |
          # 환경 변수 설정
          export DB_PASSWORD="${{ secrets.AWS_DB_PASSWORD }}"
          export REDIS_PASSWORD="${{ secrets.AWS_REDIS_PASSWORD }}"
          
          # 기존 서비스 중지
          docker-compose -f docker-compose.prod.yml down
          
          # 최신 이미지 풀
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # AWS VM 배포
          docker-compose -f docker-compose.prod.yml up -d
          
          # 헬스체크
          sleep 30
          curl -f http://localhost/health || exit 1
          
          # 배포 알림
          echo "✅ AWS VM deployment completed successfully"
          echo "🌐 Application URL: http://${{ secrets.AWS_VM_HOST }}"
          echo "📊 Metrics URL: http://${{ secrets.AWS_VM_HOST }}/metrics"

  # GCP VM 배포
  deploy-gcp:
    name: GCP VM 배포
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    environment: gcp-staging
    steps:
    - name: GCP VM 배포
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.GCP_VM_HOST }}
        username: ${{ secrets.GCP_VM_USERNAME }}
        key: ${{ secrets.GCP_VM_SSH_KEY }}
        script: |
          # 환경 변수 설정
          export DB_PASSWORD="${{ secrets.GCP_DB_PASSWORD }}"
          export REDIS_PASSWORD="${{ secrets.GCP_REDIS_PASSWORD }}"
          
          # 기존 서비스 중지
          docker-compose -f docker-compose.prod.yml down
          
          # 최신 이미지 풀
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # GCP VM 배포
          docker-compose -f docker-compose.prod.yml up -d
          
          # 헬스체크
          sleep 30
          curl -f http://localhost/health || exit 1
          
          # 배포 알림
          echo "✅ GCP VM deployment completed successfully"
          echo "🌐 Application URL: http://${{ secrets.GCP_VM_HOST }}"
          echo "📊 Metrics URL: http://${{ secrets.GCP_VM_HOST }}/metrics"

  # AWS 프로덕션 배포
  deploy-aws-production:
    name: AWS 프로덕션 배포
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production'
    environment: aws-production
    steps:
    - name: AWS 프로덕션 배포
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.AWS_VM_HOST }}
        username: ${{ secrets.AWS_VM_USERNAME }}
        key: ${{ secrets.AWS_VM_SSH_KEY }}
        script: |
          # 환경 변수 설정
          export DB_PASSWORD="${{ secrets.AWS_DB_PASSWORD }}"
          export REDIS_PASSWORD="${{ secrets.AWS_REDIS_PASSWORD }}"
          
          # Blue-Green 배포를 위한 백업
          docker-compose -f docker-compose.prod.yml down
          docker tag ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S)
          
          # 최신 이미지 풀
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # AWS 프로덕션 배포
          docker-compose -f docker-compose.prod.yml up -d
          
          # 헬스체크
          sleep 30
          curl -f http://localhost/health || exit 1
          
          # 배포 알림
          echo "🚀 AWS Production deployment completed successfully"
          echo "🌐 Application URL: http://${{ secrets.AWS_VM_HOST }}"
          echo "📊 Metrics URL: http://${{ secrets.AWS_VM_HOST }}/metrics"
          
          # 이전 이미지 정리 (7일 이상 된 이미지)
          docker image prune -f --filter "until=168h"

  # GCP 프로덕션 배포
  deploy-gcp-production:
    name: GCP 프로덕션 배포
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production'
    environment: gcp-production
    steps:
    - name: GCP 프로덕션 배포
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.GCP_VM_HOST }}
        username: ${{ secrets.GCP_VM_USERNAME }}
        key: ${{ secrets.GCP_VM_SSH_KEY }}
        script: |
          # 환경 변수 설정
          export DB_PASSWORD="${{ secrets.GCP_DB_PASSWORD }}"
          export REDIS_PASSWORD="${{ secrets.GCP_REDIS_PASSWORD }}"
          
          # Blue-Green 배포를 위한 백업
          docker-compose -f docker-compose.prod.yml down
          docker tag ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:backup-$(date +%Y%m%d-%H%M%S)
          
          # 최신 이미지 풀
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          # GCP 프로덕션 배포
          docker-compose -f docker-compose.prod.yml up -d
          
          # 헬스체크
          sleep 30
          curl -f http://localhost/health || exit 1
          
          # 배포 알림
          echo "🚀 GCP Production deployment completed successfully"
          echo "🌐 Application URL: http://${{ secrets.GCP_VM_HOST }}"
          echo "📊 Metrics URL: http://${{ secrets.GCP_VM_HOST }}/metrics"
          
          # 이전 이미지 정리 (7일 이상 된 이미지)
          docker image prune -f --filter "until=168h"

  # 배포 후 테스트
  post-deployment-test:
    name: 배포 후 테스트
    runs-on: ubuntu-latest
    needs: [deploy-aws, deploy-gcp, deploy-aws-production, deploy-gcp-production]
    if: always() && (needs.deploy-aws.result == 'success' || needs.deploy-gcp.result == 'success' || needs.deploy-aws-production.result == 'success' || needs.deploy-gcp-production.result == 'success')
    steps:
    - name: 배포된 애플리케이션 테스트
      run: |
        # AWS 스테이징 환경 테스트
        if [ "${{ needs.deploy-aws.result }}" == "success" ]; then
          echo "Testing AWS staging environment..."
          curl -f http://${{ secrets.AWS_VM_HOST }}/health
          curl -f http://${{ secrets.AWS_VM_HOST }}/api/users
          echo "✅ AWS staging environment tests passed"
        fi
        
        # GCP 스테이징 환경 테스트
        if [ "${{ needs.deploy-gcp.result }}" == "success" ]; then
          echo "Testing GCP staging environment..."
          curl -f http://${{ secrets.GCP_VM_HOST }}/health
          curl -f http://${{ secrets.GCP_VM_HOST }}/api/users
          echo "✅ GCP staging environment tests passed"
        fi
        
        # AWS 프로덕션 환경 테스트
        if [ "${{ needs.deploy-aws-production.result }}" == "success" ]; then
          echo "Testing AWS production environment..."
          curl -f http://${{ secrets.AWS_VM_HOST }}/health
          curl -f http://${{ secrets.AWS_VM_HOST }}/api/users
          echo "✅ AWS production environment tests passed"
        fi
        
        # GCP 프로덕션 환경 테스트
        if [ "${{ needs.deploy-gcp-production.result }}" == "success" ]; then
          echo "Testing GCP production environment..."
          curl -f http://${{ secrets.GCP_VM_HOST }}/health
          curl -f http://${{ secrets.GCP_VM_HOST }}/api/users
          echo "✅ GCP production environment tests passed"
        fi

  # 알림
  notify:
    name: 배포 알림
    runs-on: ubuntu-latest
    needs: [deploy-aws, deploy-gcp, deploy-aws-production, deploy-gcp-production, post-deployment-test]
    if: always()
    steps:
    - name: 배포 결과 알림
      run: |
        echo "🎯 CI/CD Pipeline Summary"
        echo "=========================="
        echo "📦 Build: ✅ Success"
        echo "🧪 Tests: ✅ Success"
        echo "🔒 Security Scan: ✅ Success"
        echo "🚀 AWS Staging: ${{ needs.deploy-aws.result }}"
        echo "🚀 GCP Staging: ${{ needs.deploy-gcp.result }}"
        echo "🏭 AWS Production: ${{ needs.deploy-aws-production.result }}"
        echo "🏭 GCP Production: ${{ needs.deploy-gcp-production.result }}"
        echo "✅ Post-deployment Tests: ${{ needs.post-deployment-test.result }}"
        echo ""
        echo "🌐 Deployed URLs:"
        if [ "${{ needs.deploy-aws.result }}" == "success" ]; then
          echo "  AWS Staging: http://${{ secrets.AWS_VM_HOST }}"
        fi
        if [ "${{ needs.deploy-gcp.result }}" == "success" ]; then
          echo "  GCP Staging: http://${{ secrets.GCP_VM_HOST }}"
        fi
        if [ "${{ needs.deploy-aws-production.result }}" == "success" ]; then
          echo "  AWS Production: http://${{ secrets.AWS_VM_HOST }}"
        fi
        if [ "${{ needs.deploy-gcp-production.result }}" == "success" ]; then
          echo "  GCP Production: http://${{ secrets.GCP_VM_HOST }}"
        fi
        echo ""
        echo "📊 Pipeline completed at: $(date)"
